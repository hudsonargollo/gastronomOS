import { describe, it, expect, vi, beforeEach } from 'vitest';
import { AllocationAuditServiceImpl } from './allocation-audit';

// Mock the database
const mockDb = {
  insert: vi.fn().mockReturnValue({
    values: vi.fn().mockResolvedValue(undefined)
  }),
  select: vi.fn().mockReturnValue({
    from: vi.fn().mockReturnValue({
      leftJoin: vi.fn().mockReturnValue({
        where: vi.fn().mockReturnValue({
          orderBy: vi.fn().mockReturnValue({
            limit: vi.fn().mockReturnValue({
              offset: vi.fn().mockResolvedValue([])
            })
          })
        })
      })
    })
  })
};

describe('AllocationAuditService', () => {
  let auditService: AllocationAuditServiceImpl;

  beforeEach(() => {
    vi.clearAllMocks();
    auditService = new AllocationAuditServiceImpl(mockDb as any);
  });

  describe('logAllocationAudit', () => {
    it('should log audit events without throwing errors', async () => {
      const auditData = {
        tenantId: 'tenant_123',
        allocationId: 'alloc_123',
        action: 'CREATED' as const,
        oldValues: null,
        newValues: { id: 'alloc_123', quantity: 100 },
        performedBy: 'user_123',
        notes: 'Test audit log'
      };

      await expect(auditService.logAllocationAudit(auditData)).resolves.not.toThrow();
    });

    it('should handle audit logging errors gracefully', async () => {
      // Mock database error
      mockDb.insert.mockReturnValue({
        values: vi.fn().mockRejectedValue(new Error('Database error'))
      });

      const auditData = {
        tenantId: 'tenant_123',
        allocationId: 'alloc_123',
        action: 'CREATED' as const,
        oldValues: null,
        newValues: { id: 'alloc_123', quantity: 100 },
        performedBy: 'user_123'
      };

      // Should not throw even if database fails
      await expect(auditService.logAllocationAudit(auditData)).resolves.not.toThrow();
    });
  });

  describe('getAuditTrail', () => {
    it('should validate required parameters', async () => {
      await expect(
        auditService.getAuditTrail('', 'tenant_123')
      ).rejects.toThrow('Allocation ID and tenant ID are required');

      await expect(
        auditService.getAuditTrail('alloc_123', '')
      ).rejects.toThrow('Allocation ID and tenant ID are required');
    });
  });

  describe('getAuditTrailForTenant', () => {
    it('should validate tenant ID is required', async () => {
      await expect(
        auditService.getAuditTrailForTenant('')
      ).rejects.toThrow('Tenant ID is required');
    });
  });

  describe('getAuditSummary', () => {
    it('should validate tenant ID is required', async () => {
      await expect(
        auditService.getAuditSummary('')
      ).rejects.toThrow('Tenant ID is required');
    });
  });

  describe('generateComplianceReport', () => {
    it('should validate required parameters', async () => {
      const dateRange = {
        from: new Date('2024-01-01'),
        to: new Date('2024-01-31')
      };

      await expect(
        auditService.generateComplianceReport('', dateRange, 'user_123')
      ).rejects.toThrow('Tenant ID, date range, and generated by user are required');

      await expect(
        auditService.generateComplianceReport('tenant_123', { from: new Date(), to: null as any }, 'user_123')
      ).rejects.toThrow('Tenant ID, date range, and generated by user are required');

      await expect(
        auditService.generateComplianceReport('tenant_123', dateRange, '')
      ).rejects.toThrow('Tenant ID, date range, and generated by user are required');
    });
  });

  describe('exportAuditData', () => {
    it('should validate tenant ID is required', async () => {
      await expect(
        auditService.exportAuditData('')
      ).rejects.toThrow('Tenant ID is required');
    });
  });
});